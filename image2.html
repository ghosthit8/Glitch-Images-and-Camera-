<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Artifact Breaker</title>
  <style>
    :root{
      --bg:#050608;--fg:#d9ffe2;--neon:#39ff88;--muted:#7ccf9a;--border:#1b2a22;
      --danger:#ff4d6d;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    header{padding:12px 14px;border-bottom:1px solid var(--border);display:flex;gap:10px;align-items:center;justify-content:space-between}
    header b{color:var(--neon);letter-spacing:.6px}
    main{max-width:1200px;margin:0 auto;padding:12px;display:grid;gap:12px}
    .panel{border:1px solid var(--border);background:linear-gradient(180deg,#070a0d,#050608);border-radius:16px;padding:12px}
    .grid{display:grid;grid-template-columns:360px 1fr;gap:12px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .hint{color:var(--muted);font-size:13px;line-height:1.4}
    label{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:13px}
    input[type="range"]{width:180px}
    input[type="file"]{max-width:100%}
    button{
      border:1px solid var(--border);
      background:rgba(57,255,136,.07);
      color:var(--fg);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      transition:.15s transform,.15s background,.15s border-color;
      user-select:none
    }
    button:hover{transform:translateY(-1px);border-color:rgba(57,255,136,.35);background:rgba(57,255,136,.12)}
    button.danger{background:rgba(255,77,109,.08);border-color:rgba(255,77,109,.25)}
    button.danger:hover{border-color:rgba(255,77,109,.5);background:rgba(255,77,109,.12)}
    button.ghost{background:transparent}
    .canvasWrap{
      position:relative;
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      background:#000;
      min-height:320px;
      display:grid;
      place-items:center;
    }
    canvas{max-width:100%;height:auto;display:block}
    .badge{
      position:absolute;left:10px;top:10px;
      padding:6px 10px;border-radius:999px;
      font-size:12px;
      border:1px solid rgba(57,255,136,.28);
      background:rgba(0,0,0,.45);
      color:var(--fg);
      backdrop-filter: blur(6px);
    }
    .badge.pause{border-color:rgba(255,77,109,.45)}
    .footerRow{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
    .small{font-size:12px;color:var(--muted)}
    .divider{height:1px;background:var(--border);margin:10px 0}
  </style>
</head>
<body>
  <header>
    <div><b>RAGE</b> ‚Ä¢ Artifact Breaker</div>
    <div class="row">
      <a href="index.html" style="color:var(--muted);text-decoration:none">‚Üê menu</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="grid">
        <div class="panel" style="padding:12px">
          <div class="row" style="justify-content:space-between">
            <div>
              <div style="font-weight:700">Controls</div>
              <div class="hint">Breaks the image into ‚Äúcompression blocks‚Äù and corrupts them.</div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="row">
            <input id="file" type="file" accept="image/*" />
          </div>

          <div class="divider"></div>

          <div class="row">
            <label>Tile size
              <input id="tile" type="range" min="6" max="64" value="18" />
              <span id="tileVal">18</span>
            </label>
          </div>

          <div class="row">
            <label>Break amount
              <input id="breakAmt" type="range" min="0" max="100" value="55" />
              <span id="breakVal">55</span>
            </label>
          </div>

          <div class="row">
            <label>Swap chaos
              <input id="swapAmt" type="range" min="0" max="100" value="35" />
              <span id="swapVal">35</span>
            </label>
          </div>

          <div class="row">
            <label>Drop blocks
              <input id="dropAmt" type="range" min="0" max="100" value="18" />
              <span id="dropVal">18</span>
            </label>
          </div>

          <div class="row">
            <label>Chroma offset
              <input id="chroma" type="range" min="0" max="16" value="6" />
              <span id="chromaVal">6</span>
            </label>
          </div>

          <div class="row">
            <label>Scanlines
              <input id="scan" type="range" min="0" max="100" value="35" />
              <span id="scanVal">35</span>
            </label>
          </div>

          <div class="divider"></div>

          <div class="row">
            <button id="toggle">‚è∏ Pause</button>
            <button id="step" class="ghost" title="Render one frame while paused">‚è≠ Step</button>
          </div>

          <div class="row">
            <button id="reseed">üîÅ Reseed</button>
            <button id="reset" class="danger">‚úñ Reset</button>
          </div>

          <div class="divider"></div>

          <div class="row">
            <button id="export">‚¨á Export PNG</button>
          </div>

          <div class="divider"></div>
          <div class="small">
            Tip: Smaller tile size + higher break = crunchy macroblock shatter. Pause freezes the moving corruption (not a ‚Äúfreeze frame‚Äù function).
          </div>
        </div>

        <div class="canvasWrap">
          <div id="badge" class="badge">LIVE</div>
          <canvas id="c" width="960" height="540"></canvas>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const file = $("file");
  const c = $("c");
  const ctx = c.getContext("2d", { willReadFrequently: true });

  // offscreen buffers
  const src = document.createElement("canvas");
  const sctx = src.getContext("2d", { willReadFrequently: true });

  const tmp = document.createElement("canvas");
  const tctx = tmp.getContext("2d", { willReadFrequently: true });

  // UI
  const tile = $("tile"), tileVal = $("tileVal");
  const breakAmt = $("breakAmt"), breakVal = $("breakVal");
  const swapAmt = $("swapAmt"), swapVal = $("swapVal");
  const dropAmt = $("dropAmt"), dropVal = $("dropVal");
  const chroma = $("chroma"), chromaVal = $("chromaVal");
  const scan = $("scan"), scanVal = $("scanVal");
  const toggle = $("toggle");
  const stepBtn = $("step");
  const reseedBtn = $("reseed");
  const resetBtn = $("reset");
  const exportBtn = $("export");
  const badge = $("badge");

  // state
  let W = c.width, H = c.height;
  let running = true;
  let hasImage = false;
  let raf = 0;
  let seed = (Math.random() * 1e9) | 0;

  // tile cache
  let tiles = []; // {sx,sy,sw,sh, dx,dy, jitterX,jitterY}
  let cols = 0, rows = 0;

  // tiny RNG (deterministic per seed)
  function mulberry32(a){
    return function(){
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }
  let rand = mulberry32(seed);

  function setBadge(){
    badge.textContent = running ? "LIVE" : "PAUSED";
    badge.classList.toggle("pause", !running);
    toggle.textContent = running ? "‚è∏ Pause" : "‚ñ∂ Resume";
  }

  function fitToCanvas(img){
    // Keep a nice wide default if user uploads portrait; fit + center.
    const maxW = 1200;
    const maxH = 720;

    let iw = img.naturalWidth || img.width;
    let ih = img.naturalHeight || img.height;

    let scale = Math.min(maxW / iw, maxH / ih, 1);
    W = Math.max(320, Math.round(iw * scale));
    H = Math.max(320, Math.round(ih * scale));

    c.width = W; c.height = H;

    src.width = W; src.height = H;
    tmp.width = W; tmp.height = H;

    // draw fitted image to src
    sctx.clearRect(0,0,W,H);
    sctx.drawImage(img, 0, 0, W, H);
  }

  function buildTiles(){
    tiles = [];
    const ts = parseInt(tile.value, 10);
    cols = Math.ceil(W / ts);
    rows = Math.ceil(H / ts);

    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const sx = x*ts;
        const sy = y*ts;
        const sw = Math.min(ts, W - sx);
        const sh = Math.min(ts, H - sy);
        tiles.push({
          sx, sy, sw, sh,
          dx: sx, dy: sy,
          jitterX: 0, jitterY: 0,
          crush: 0
        });
      }
    }
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  function drawScanlines(amount){
    if(amount <= 0) return;
    const a = amount / 100;
    ctx.save();
    ctx.globalAlpha = 0.22 * a;
    for(let y=0; y<H; y+=2){
      ctx.fillRect(0,y,W,1);
    }
    ctx.globalAlpha = 0.10 * a;
    for(let y=0; y<H; y+=6){
      ctx.fillRect(0,y,W,1);
    }
    ctx.restore();
  }

  function drawChroma(offset){
    if(offset <= 0) return;
    // simple RGB split using additive channels
    const off = offset|0;
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = 0.20;
    ctx.drawImage(c, -off, 0);
    ctx.globalAlpha = 0.16;
    ctx.drawImage(c, off, 0);
    ctx.restore();
  }

  function corruptFrame(){
    if(!hasImage){
      // idle screen
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(57,255,136,.85)";
      ctx.font = "700 16px system-ui";
      ctx.fillText("Upload an image to break it into artifacts.", 18, 32);
      ctx.fillStyle = "rgba(57,255,136,.55)";
      ctx.font = "13px system-ui";
      ctx.fillText("Try: tile size 12‚Äì22, break 50‚Äì80, swap 20‚Äì60.", 18, 54);
      return;
    }

    const ts = parseInt(tile.value, 10);
    const br = parseInt(breakAmt.value, 10) / 100;
    const swp = parseInt(swapAmt.value, 10) / 100;
    const drp = parseInt(dropAmt.value, 10) / 100;

    // start from clean image into tmp (so corruption compounds in this frame only, not permanently)
    tctx.clearRect(0,0,W,H);
    tctx.drawImage(src, 0,0);

    // optional "crush" (fake compression): downscale/upscale a region
    // We'll do this per-tile by drawing via a tiny buffer.
    // (This keeps it GitHub Pages friendly; no fancy codecs.)
    ctx.clearRect(0,0,W,H);

    // occasionally reshuffle some tiles
    if(swp > 0){
      const swaps = Math.floor(tiles.length * 0.02 * swp);
      for(let i=0;i<swaps;i++){
        const a = (rand()*tiles.length)|0;
        const b = (rand()*tiles.length)|0;
        const ta = tiles[a], tb = tiles[b];
        const dx = ta.dx, dy = ta.dy;
        ta.dx = tb.dx; ta.dy = tb.dy;
        tb.dx = dx; tb.dy = dy;
      }
    }

    // draw tiles with ‚Äúartifact break‚Äù
    for(let i=0;i<tiles.length;i++){
      const T = tiles[i];

      // jitter probability
      const jProb = br * 0.55;
      if(rand() < jProb){
        const mag = (ts * 0.65) * br;
        T.jitterX = (rand()*2 - 1) * mag;
        T.jitterY = (rand()*2 - 1) * mag;
      } else {
        // decay jitter
        T.jitterX *= 0.62;
        T.jitterY *= 0.62;
      }

      // occasional "crush level" change
      if(rand() < br * 0.18){
        T.crush = clamp(T.crush + (rand()*2 - 1) * 0.35, 0, 1);
      } else {
        T.crush *= 0.94;
      }

      // drop blocks (black/green missing macroblocks)
      if(drp > 0 && rand() < drp * (0.08 + br*0.25)){
        ctx.fillStyle = (rand() < 0.2) ? "rgba(57,255,136,.25)" : "rgba(0,0,0,.85)";
        ctx.fillRect(T.dx + T.jitterX, T.dy + T.jitterY, T.sw, T.sh);
        continue;
      }

      // draw tile, sometimes from a wrong source position (artifact misreference)
      let sx = T.sx, sy = T.sy;
      if(rand() < br * 0.22){
        const rx = ((rand()*cols)|0) * ts;
        const ry = ((rand()*rows)|0) * ts;
        sx = clamp(rx, 0, W - T.sw);
        sy = clamp(ry, 0, H - T.sh);
      }

      // "compression crush": sample at lower res then scale up
      const crush = T.crush * br;
      if(crush > 0.01){
        const down = clamp(Math.round(ts * (0.25 + 0.75*(1-crush))), 2, ts);
        // draw source tile into a tiny area then scale to destination
        // reuse tmp canvas as source; use tctx as clean
        // make a tiny buffer on the fly using drawImage with scaled sizes
        ctx.imageSmoothingEnabled = false;
        // draw to a tiny part of tmp (top-left scratch)
        const scratchW = down, scratchH = down;
        // copy a tile region into scratch at reduced size
        // First draw region into scratch sized box:
        tctx.imageSmoothingEnabled = true;
        // we‚Äôll just draw direct to ctx using 2-step scaling:
        // step 1: draw region tiny to ctx offscreen? Too heavy.
        // Instead: approximate by drawing region to ctx with very low smoothing.
        // We'll do: drawImage(region) into smaller dest then re-draw to full tile.
        ctx.save();
        ctx.globalAlpha = 1;
        // small draw
        ctx.drawImage(tmp, sx, sy, T.sw, T.sh,
          (T.dx + T.jitterX), (T.dy + T.jitterY),
          Math.max(2, Math.round(T.sw * (down/ts))),
          Math.max(2, Math.round(T.sh * (down/ts)))
        );
        // then blow-up from that small draw by drawing the same area from the canvas
        const dx2 = T.dx + T.jitterX;
        const dy2 = T.dy + T.jitterY;
        const dw2 = Math.max(2, Math.round(T.sw * (down/ts)));
        const dh2 = Math.max(2, Math.round(T.sh * (down/ts)));

        // copy that crushed part back over itself scaled up (pixelated)
        ctx.drawImage(c,
          dx2, dy2, dw2, dh2,
          dx2, dy2, T.sw, T.sh
        );
        ctx.restore();
        continue;
      }

      // normal draw
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(tmp, sx, sy, T.sw, T.sh,
        T.dx + T.jitterX, T.dy + T.jitterY, T.sw, T.sh
      );

      // occasional edge tear highlight
      if(rand() < br * 0.04){
        ctx.fillStyle = "rgba(57,255,136,.16)";
        ctx.fillRect(T.dx + T.jitterX, T.dy + T.jitterY, T.sw, 1);
      }
    }

    // overlays
    ctx.fillStyle = "rgba(0,0,0,0.0)";
    drawScanlines(parseInt(scan.value, 10));
    drawChroma(parseInt(chroma.value, 10));
  }

  function loop(){
    raf = requestAnimationFrame(loop);
    if(!running) return;
    corruptFrame();
  }

  function reseed(){
    seed = (Math.random() * 1e9) | 0;
    rand = mulberry32(seed);
  }

  function hardReset(){
    hasImage = false;
    tiles = [];
    ctx.clearRect(0,0,c.width,c.height);
    c.width = 960; c.height = 540;
    W = c.width; H = c.height;
    src.width = W; src.height = H;
    tmp.width = W; tmp.height = H;
    reseed();
    corruptFrame();
  }

  // UI bindings
  function bindRange(r, out){
    const fn = () => out.textContent = r.value;
    r.addEventListener("input", fn);
    fn();
  }
  bindRange(tile, tileVal);
  bindRange(breakAmt, breakVal);
  bindRange(swapAmt, swapVal);
  bindRange(dropAmt, dropVal);
  bindRange(chroma, chromaVal);
  bindRange(scan, scanVal);

  tile.addEventListener("change", () => { if(hasImage) buildTiles(); });

  toggle.addEventListener("click", () => {
    running = !running;
    setBadge();
    if(!running) corruptFrame(); // render the paused frame
  });

  stepBtn.addEventListener("click", () => {
    if(running) return;
    corruptFrame();
  });

  reseedBtn.addEventListener("click", () => {
    reseed();
    if(!running) corruptFrame();
  });

  resetBtn.addEventListener("click", () => {
    hardReset();
    setBadge();
  });

  exportBtn.addEventListener("click", () => {
    const a = document.createElement("a");
    a.download = "artifact_break.png";
    a.href = c.toDataURL("image/png");
    a.click();
  });

  file.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if(!f) return;

    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      fitToCanvas(img);
      hasImage = true;
      reseed();
      buildTiles();
      corruptFrame();
    };
    img.src = url;
  });

  // init
  setBadge();
  corruptFrame();
  loop();
})();
</script>
</body>
</html>