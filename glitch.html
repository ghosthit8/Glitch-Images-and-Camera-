<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Glitch Lab</title>
  <style>
    :root{
      --bg:#050608;
      --fg:#d9ffe2;
      --neon:#39ff88;
      --muted:#7ccf9a;
      --panel:#0b0f10;
      --border:#1b2a22;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 50% 0%, #0a1a12 0%, var(--bg) 55%);
      color:var(--fg);
    }
    header{
      padding:14px 14px 8px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(57,255,136,.10), transparent);
    }
    .title{
      display:flex; flex-direction:column; gap:4px;
    }
    .title b{
      letter-spacing:.5px;
      color:var(--neon);
      text-shadow:0 0 10px rgba(57,255,136,.35);
    }
    .title small{color:var(--muted)}
    main{
      padding:12px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      max-width:1100px;
      margin:0 auto;
    }
    .panel{
      background: rgba(11,15,16,.75);
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
    }
    .controls{
      padding:12px;
      display:grid;
      gap:10px;
    }
    .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    button, label.btn{
      appearance:none;
      border:1px solid var(--border);
      background:#08110d;
      color:var(--fg);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      gap:8px;
      align-items:center;
      transition: transform .05s ease, border-color .2s ease, box-shadow .2s ease;
    }
    button:hover, label.btn:hover{
      border-color: rgba(57,255,136,.45);
      box-shadow: 0 0 0 2px rgba(57,255,136,.10) inset, 0 0 18px rgba(57,255,136,.08);
    }
    button:active, label.btn:active{transform: translateY(1px)}
    button.primary{
      background: linear-gradient(180deg, rgba(57,255,136,.25), rgba(57,255,136,.08));
      border-color: rgba(57,255,136,.45);
    }
    button.danger{
      border-color: rgba(255,80,80,.35);
      background: rgba(255,80,80,.08);
    }
    input[type="file"]{display:none}
    .slider{
      display:flex; flex-direction:column; gap:6px;
      min-width: 220px;
    }
    .slider label{color:var(--muted); font-size:12px}
    input[type="range"]{
      width:100%;
      accent-color: var(--neon);
    }
    .canvasWrap{
      position:relative;
      width:100%;
      aspect-ratio: 16/9;
      background: #000;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }
    .overlay{
      pointer-events:none;
      position:absolute; inset:0;
      background:
        linear-gradient(to bottom, rgba(57,255,136,.08), transparent 30%),
        repeating-linear-gradient(to bottom, rgba(255,255,255,.06) 0px, rgba(255,255,255,.06) 1px, transparent 2px, transparent 4px);
      mix-blend-mode: overlay;
      opacity:.35;
    }
    .status{
      padding:10px 12px;
      color:var(--muted);
      font-size:13px;
      border-top:1px solid var(--border);
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }
    .pill{
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.25);
      color: var(--fg);
      font-size:12px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media (min-width: 900px){
      .grid2{grid-template-columns: 1fr 360px;}
    }
    .hint{font-size:12px; color:var(--muted); padding:0 12px 12px}
    a{color:var(--neon)}
  </style>
</head>

<body>
<header>
  <div class="title">
    <b>GLITCH LAB</b>
    <small>Upload images or glitch your live camera feed (canvas-based)</small>
  </div>
  <div class="pill" id="fpsReadout">FPS: --</div>
</header>

<main class="grid2">

  <section class="panel">
    <div class="canvasWrap">
      <canvas id="c"></canvas>
      <div class="overlay"></div>
    </div>
    <div class="status">
      <div class="pill" id="modePill">Mode: idle</div>
      <div class="pill" id="sizePill">Canvas: --</div>
      <div class="pill" id="infoPill">Tip: upload an image or start camera</div>
    </div>
  </section>

  <aside class="panel">
    <div class="controls">

      <div class="row">
        <label class="btn">
          üìÅ Load Image
          <input id="file" type="file" accept="image/*" />
        </label>
        <button id="clear" class="danger">üßπ Clear</button>
      </div>

      <div class="row">
        <button id="camStart" class="primary">üì∑ Start Camera</button>
        <button id="camStop" class="danger" disabled>‚õî Stop</button>
        <button id="switchCam" disabled>üîÅ Switch</button>
      </div>

      <div class="row">
        <button id="toggleGlitch" class="primary">‚ö° Glitch: ON</button>
        <button id="freeze">üßä Freeze</button>
        <button id="snap">üíæ Save Frame</button>
      </div>

      <div class="slider">
        <label for="intensity">Glitch intensity: <span id="intensityVal">0.55</span></label>
        <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.55"/>
      </div>

      <div class="slider">
        <label for="fps">Target FPS: <span id="fpsVal">30</span></label>
        <input id="fps" type="range" min="5" max="60" step="1" value="30"/>
      </div>

      <div class="slider">
        <label for="seed">Randomness (seed drift): <span id="seedVal">0.35</span></label>
        <input id="seed" type="range" min="0" max="1" step="0.01" value="0.35"/>
      </div>

    </div>

    <div class="hint">
      Notes:
      <ul>
        <li>Camera needs <b>HTTPS</b> or <b>localhost</b> in most browsers.</li>
        <li>On Android Chrome, opening this as a local file sometimes blocks camera; hosting it locally fixes it.</li>
        <li>This uses only your device ‚Äî nothing uploads anywhere.</li>
      </ul>
    </div>
  </aside>

</main>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  const file = document.getElementById('file');
  const clearBtn = document.getElementById('clear');

  const camStart = document.getElementById('camStart');
  const camStop = document.getElementById('camStop');
  const switchCam = document.getElementById('switchCam');

  const toggleGlitch = document.getElementById('toggleGlitch');
  const freezeBtn = document.getElementById('freeze');
  const snapBtn = document.getElementById('snap');

  const intensity = document.getElementById('intensity');
  const fps = document.getElementById('fps');
  const seed = document.getElementById('seed');

  const intensityVal = document.getElementById('intensityVal');
  const fpsVal = document.getElementById('fpsVal');
  const seedVal = document.getElementById('seedVal');

  const modePill = document.getElementById('modePill');
  const sizePill = document.getElementById('sizePill');
  const infoPill = document.getElementById('infoPill');
  const fpsReadout = document.getElementById('fpsReadout');

  const hiddenVideo = document.createElement('video');
  hiddenVideo.playsInline = true;
  hiddenVideo.muted = true;
  hiddenVideo.autoplay = true;

  let srcImage = null;
  let stream = null;
  let useCamera = false;
  let frozen = false;
  let glitchOn = true;

  let facingMode = 'environment'; // try back camera first
  let t = 0;
  let lastFrameTime = 0;
  let lastFpsTime = 0;
  let frames = 0;
  let measuredFps = 0;

  function setMode(text){
    modePill.textContent = `Mode: ${text}`;
  }

  function fitCanvasToSource(w, h){
    // Keep canvas roughly matching the visible 16:9 area but preserve source resolution reasonably.
    // We'll set actual canvas size based on source but clamp for performance.
    const maxW = 1280; // performance-friendly
    const scale = Math.min(1, maxW / w);
    canvas.width = Math.round(w * scale);
    canvas.height = Math.round(h * scale);
    sizePill.textContent = `Canvas: ${canvas.width}√ó${canvas.height}`;
  }

  function rand(seedVal){
    // Simple deterministic-ish PRNG
    const x = Math.sin(seedVal) * 10000;
    return x - Math.floor(x);
  }

  function glitchPass(imageData, intensityAmt, seedAmt){
    const { width:w, height:h, data } = imageData;

    // 1) Add scanline-ish darkness + noise
    const noiseAmt = 20 * intensityAmt;
    const scanAmt = 0.18 * intensityAmt;

    for (let y=0; y<h; y++){
      const scan = (y % 3 === 0) ? (1 - scanAmt) : 1;
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        const n = (Math.random() - 0.5) * noiseAmt;

        data[i]   = Math.max(0, Math.min(255, (data[i]   + n) * scan));
        data[i+1] = Math.max(0, Math.min(255, (data[i+1] + n) * scan));
        data[i+2] = Math.max(0, Math.min(255, (data[i+2] + n) * scan));
        // alpha unchanged
      }
    }

    // 2) Horizontal slice shifts ("datamosh slices")
    const slices = Math.floor(6 + intensityAmt * 22);
    for (let s=0; s<slices; s++){
      const y = Math.floor(Math.random() * h);
      const sliceH = Math.max(1, Math.floor((Math.random() * 18 + 2) * intensityAmt));
      const dx = Math.floor((Math.random() - 0.5) * w * 0.25 * intensityAmt);

      for (let yy=y; yy<Math.min(h, y+sliceH); yy++){
        // shift row by copying pixels
        const rowStart = yy*w*4;
        const row = data.slice(rowStart, rowStart + w*4);

        for (let x=0; x<w; x++){
          const srcX = (x - dx + w) % w;
          const di = rowStart + x*4;
          const si = srcX*4;
          data[di]   = row[si];
          data[di+1] = row[si+1];
          data[di+2] = row[si+2];
        }
      }
    }

    // 3) RGB channel split (chromatic aberration)
    const split = Math.floor(1 + intensityAmt * 10);
    const copy = data.slice(); // snapshot
    const rShift = split;
    const gShift = -split;
    const bShift = split * 2;

    function sample(src, x, y, c){
      x = (x + w) % w; y = (y + h) % h;
      return src[(y*w + x)*4 + c];
    }

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;

        // Use seedAmt to slightly drift split direction over time
        const drift = (Math.sin(seedAmt) * 2) * intensityAmt;

        data[i]   = sample(copy, x + rShift + drift, y, 0); // R
        data[i+1] = sample(copy, x + gShift - drift, y, 1); // G
        data[i+2] = sample(copy, x + bShift, y, 2);         // B
      }
    }

    // 4) Occasional "pixel burn" blocks
    const blocks = Math.floor(intensityAmt * 18);
    for (let b=0; b<blocks; b++){
      if (Math.random() > intensityAmt) continue;
      const bw = Math.floor(10 + Math.random()*60*intensityAmt);
      const bh = Math.floor(6 + Math.random()*40*intensityAmt);
      const bx = Math.floor(Math.random() * (w - 1));
      const by = Math.floor(Math.random() * (h - 1));
      const tint = 40 + Math.random()*120;

      for (let y=by; y<Math.min(h, by+bh); y++){
        for (let x=bx; x<Math.min(w, bx+bw); x++){
          const i = (y*w + x)*4;
          data[i]   = Math.min(255, data[i]   + tint);
          data[i+1] = Math.max(0,   data[i+1] - tint*0.35);
          data[i+2] = Math.min(255, data[i+2] + tint*0.2);
        }
      }
    }

    return imageData;
  }

  function drawSource(){
    // Draw image or video into canvas
    if (useCamera && hiddenVideo.readyState >= 2){
      ctx.drawImage(hiddenVideo, 0, 0, canvas.width, canvas.height);
    } else if (srcImage){
      ctx.drawImage(srcImage, 0, 0, canvas.width, canvas.height);
    } else {
      // idle screen
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "rgba(57,255,136,.8)";
      ctx.font = "16px system-ui";
      ctx.fillText("Load an image or start camera‚Ä¶", 18, 34);
    }
  }

  function loop(now){
    const target = 1000 / Number(fps.value);
    if (!lastFrameTime) lastFrameTime = now;
    const elapsed = now - lastFrameTime;

    if (elapsed >= target){
      lastFrameTime = now - (elapsed % target);

      if (!frozen){
        drawSource();

        if (glitchOn){
          const img = ctx.getImageData(0,0,canvas.width,canvas.height);
          const intensityAmt = Number(intensity.value);
          const seedAmt = t * (0.4 + Number(seed.value)*2.2);
          const glitched = glitchPass(img, intensityAmt, seedAmt);
          ctx.putImageData(glitched, 0, 0);
        }
      }

      // FPS meter
      frames++;
      if (!lastFpsTime) lastFpsTime = now;
      if (now - lastFpsTime >= 700){
        measuredFps = Math.round((frames * 1000) / (now - lastFpsTime));
        frames = 0;
        lastFpsTime = now;
        fpsReadout.textContent = `FPS: ${measuredFps}`;
      }

      t += 0.016;
    }

    requestAnimationFrame(loop);
  }

  // UI bindings
  intensity.addEventListener('input', () => intensityVal.textContent = Number(intensity.value).toFixed(2));
  fps.addEventListener('input', () => fpsVal.textContent = fps.value);
  seed.addEventListener('input', () => seedVal.textContent = Number(seed.value).toFixed(2));

  toggleGlitch.addEventListener('click', () => {
    glitchOn = !glitchOn;
    toggleGlitch.textContent = glitchOn ? "‚ö° Glitch: ON" : "‚ö° Glitch: OFF";
    toggleGlitch.classList.toggle('primary', glitchOn);
  });

  freezeBtn.addEventListener('click', () => {
    frozen = !frozen;
    freezeBtn.textContent = frozen ? "‚ñ∂ Unfreeze" : "üßä Freeze";
    infoPill.textContent = frozen ? "Frozen frame (effects paused)" : "Live rendering";
  });

  snapBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = `glitch_${Date.now()}.png`;
    a.href = canvas.toDataURL('image/png');
    a.click();
  });

  clearBtn.addEventListener('click', () => {
    srcImage = null;
    useCamera = false;
    setMode('idle');
    infoPill.textContent = "Cleared. Load an image or start camera.";
    if (!canvas.width) { canvas.width = 1280; canvas.height = 720; }
  });

  file.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;

    const img = new Image();
    img.onload = () => {
      srcImage = img;
      useCamera = false;
      fitCanvasToSource(img.naturalWidth, img.naturalHeight);
      setMode('image');
      infoPill.textContent = `Loaded: ${f.name}`;
    };
    img.onerror = () => {
      infoPill.textContent = "Could not load that image.";
    };
    img.src = URL.createObjectURL(f);
  });

  async function startCamera(){
    try{
      // Stop any existing stream first
      await stopCamera();

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode },
        audio: false
      });

      hiddenVideo.srcObject = stream;
      await hiddenVideo.play();

      // When video has dimensions, fit canvas
      const w = hiddenVideo.videoWidth || 1280;
      const h = hiddenVideo.videoHeight || 720;
      fitCanvasToSource(w, h);

      useCamera = true;
      setMode('camera');
      infoPill.textContent = `Camera started (${facingMode})`;

      camStop.disabled = false;
      switchCam.disabled = false;
    } catch(err){
      console.error(err);
      infoPill.textContent = "Camera blocked. Try hosting this over HTTPS or using localhost.";
      useCamera = false;
      setMode('idle');
    }
  }

  async function stopCamera(){
    if (stream){
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
    hiddenVideo.srcObject = null;
    camStop.disabled = true;
    switchCam.disabled = true;
  }

  camStart.addEventListener('click', startCamera);
  camStop.addEventListener('click', async () => {
    await stopCamera();
    useCamera = false;
    setMode(srcImage ? 'image' : 'idle');
    infoPill.textContent = "Camera stopped.";
  });

  switchCam.addEventListener('click', async () => {
    facingMode = (facingMode === 'environment') ? 'user' : 'environment';
    infoPill.textContent = "Switching camera‚Ä¶";
    await startCamera();
  });

  // Init canvas size
  canvas.width = 1280;
  canvas.height = 720;
  sizePill.textContent = `Canvas: ${canvas.width}√ó${canvas.height}`;

  // Kick off animation loop
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
