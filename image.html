<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Image Glitch</title>
  <style>
    :root{--bg:#050608;--fg:#d9ffe2;--neon:#39ff88;--muted:#7ccf9a;--border:#1b2a22}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui}
    header{padding:12px 14px;border-bottom:1px solid var(--border);display:flex;gap:10px;align-items:center;justify-content:space-between}
    header b{color:var(--neon);letter-spacing:.6px}
    main{max-width:1100px;margin:0 auto;padding:12px;display:grid;gap:12px}
    .panel{border:1px solid var(--border);border-radius:14px;overflow:hidden;background:#070b0c}
    .wrap{position:relative;width:100%;aspect-ratio:16/9;background:#000}
    canvas{width:100%;height:100%;display:block}
    .overlay{
      pointer-events:none; position:absolute; inset:0;
      background: repeating-linear-gradient(to bottom, rgba(255,255,255,.06) 0px, rgba(255,255,255,.06) 1px, transparent 2px, transparent 4px);
      mix-blend-mode: overlay; opacity:.35;
    }
    .controls{padding:12px;display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    button{
      border:1px solid var(--border); background:#08110d; color:var(--fg);
      padding:10px 12px; border-radius:12px; cursor:pointer;
    }
    button.primary{border-color:rgba(57,255,136,.45);background:rgba(57,255,136,.12)}
    button.danger{border-color:rgba(255,80,80,.35);background:rgba(255,80,80,.10)}
    button:disabled{opacity:.5;cursor:not-allowed}
    .slider{min-width:220px;display:flex;flex-direction:column;gap:6px}
    .slider label{font-size:12px;color:var(--muted)}
    input[type=range]{width:100%;accent-color:var(--neon)}
    .meta{padding:0 12px 12px;color:var(--muted);font-size:12px}
    a{color:var(--neon);text-decoration:none}
    input[type=file]{display:none}
  </style>
</head>
<body>
<header>
  <div><b>Image Glitch</b> <span style="color:#7ccf9a;font-size:12px">upload an image and glitch it</span></div>
  <a href="./index.html">‚Üê back</a>
</header>

<main>
  <section class="panel">
    <div class="wrap">
      <canvas id="c"></canvas>
      <div class="overlay"></div>
    </div>

    <div class="controls">
      <label>
        <input id="file" type="file" accept="image/*" />
        <button id="load" class="primary">üìÅ Load Image</button>
      </label>

      <button id="toggle" class="primary">‚ö° Glitch: ON</button>

      <!-- NEW: Pause (locks glitch motion but still re-renders when settings change) -->
      <button id="pause">‚è∏ Pause</button>

      <button id="freeze">üßä Freeze</button>
      <button id="save">üíæ Save</button>
      <button id="clear" class="danger">üßπ Clear</button>

      <div class="slider">
        <label>Intensity: <span id="ival">0.60</span></label>
        <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.60">
      </div>

      <div class="slider">
        <label>FPS: <span id="fval">30</span></label>
        <input id="fps" type="range" min="5" max="60" step="1" value="30">
      </div>

      <div class="slider">
        <label>Randomness: <span id="rval">0.60</span></label>
        <input id="randomness" type="range" min="0" max="1" step="0.01" value="0.60">
      </div>
    </div>

    <div class="meta">
      Loaded: <span id="loaded">none</span>
    </div>
  </section>
</main>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  const fileInput = document.getElementById('file');
  const loadBtn = document.getElementById('load');
  const toggleBtn = document.getElementById('toggle');
  const pauseBtn = document.getElementById('pause');
  const freezeBtn = document.getElementById('freeze');
  const saveBtn = document.getElementById('save');
  const clearBtn = document.getElementById('clear');

  const intensity = document.getElementById('intensity');
  const fps = document.getElementById('fps');
  const randomness = document.getElementById('randomness');

  const ival = document.getElementById('ival');
  const fval = document.getElementById('fval');
  const rval = document.getElementById('rval');
  const loadedEl = document.getElementById('loaded');

  // Offscreen base canvas holds the original image scaled to our render size
  const base = document.createElement('canvas');
  const bctx = base.getContext('2d', { willReadFrequently: true });

  let imgLoaded = false;
  let glitchOn = true;

  // Freeze = lock final pixels (no redraw)
  let frozen = false;

  // Pause = lock motion seed, but still redraw when controls change
  let paused = false;

  // Seeds for deterministic-ish glitching
  let motionSeed = 1337;      // changes over time when not paused
  let pausedSeed = 1337;      // captured when pausing

  // animation timing
  let lastFrame = 0;
  let tick = 0;

  function fitCanvasToImage(w, h){
    const maxW = 1400;
    const scale = Math.min(1, maxW / w);
    const cw = Math.max(1, Math.round(w * scale));
    const ch = Math.max(1, Math.round(h * scale));

    canvas.width = cw; canvas.height = ch;
    base.width = cw; base.height = ch;
  }

  // Tiny deterministic PRNG so "Pause" can lock motion
  function mulberry32(a){
    return function() {
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  function clamp255(x){ return x < 0 ? 0 : (x > 255 ? 255 : x); }

  function glitchPass(imageData, amt, randAmt, seed){
    const { width:w, height:h, data } = imageData;
    const rng = mulberry32(seed);

    // noise + scanlines
    const noise = 18 * amt * randAmt;
    const scanAmt = 0.22 * amt;

    for (let y = 0; y < h; y++){
      const scan = (y % 3 === 0) ? (1 - scanAmt) : 1;
      for (let x = 0; x < w; x++){
        const i = (y*w + x)*4;
        const n = (rng() - 0.5) * noise;
        data[i]   = clamp255((data[i]   + n) * scan);
        data[i+1] = clamp255((data[i+1] + n) * scan);
        data[i+2] = clamp255((data[i+2] + n) * scan);
      }
    }

    // slice shifts
    const slices = Math.floor(4 + amt * 18 * randAmt);
    for (let s=0; s<slices; s++){
      const y = Math.floor(rng() * h);
      const sliceH = Math.max(1, Math.floor((rng() * 18 + 2) * amt));
      const dx = Math.floor((rng() - 0.5) * w * 0.28 * amt * randAmt);

      for (let yy=y; yy<Math.min(h, y+sliceH); yy++){
        const rowStart = yy*w*4;
        const row = data.slice(rowStart, rowStart + w*4);
        for (let x=0; x<w; x++){
          const srcX = (x - dx + w) % w;
          const di = rowStart + x*4;
          const si = srcX*4;
          data[di]   = row[si];
          data[di+1] = row[si+1];
          data[di+2] = row[si+2];
        }
      }
    }

    // rgb split
    const split = Math.floor(1 + amt * 10 * randAmt);
    const copy = data.slice();

    const sample = (src, x, y, c) => {
      x = (x + w) % w; y = (y + h) % h;
      return src[(y*w + x)*4 + c];
    };

    // small drift derived from seed (so it locks on pause)
    const drift = Math.floor(((rng()*2)-1) * 3 * amt);

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        data[i]   = sample(copy, x + split + drift, y, 0);
        data[i+1] = sample(copy, x - split - drift, y, 1);
        data[i+2] = sample(copy, x + split*2, y, 2);
      }
    }

    return imageData;
  }

  function renderOnce(){
    if (!imgLoaded) {
      // placeholder
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "rgba(57,255,136,.9)";
      ctx.font = "16px system-ui";
      ctx.fillText("Load an image to begin", 18, 30);
      return;
    }

    // Draw base image first
    ctx.drawImage(base, 0, 0, canvas.width, canvas.height);

    if (glitchOn){
      const amt = Number(intensity.value);
      const randAmt = Number(randomness.value);

      // IMPORTANT:
      // - when paused, use pausedSeed (locked) so the glitch stops "moving"
      // - otherwise, use motionSeed which updates every frame
      const seed = paused ? pausedSeed : motionSeed;

      const img = ctx.getImageData(0,0,canvas.width,canvas.height);
      ctx.putImageData(glitchPass(img, amt, randAmt, seed), 0, 0);
    }
  }

  function loop(now){
    const target = 1000 / Number(fps.value);
    if (!lastFrame) lastFrame = now;
    const elapsed = now - lastFrame;

    if (elapsed >= target){
      lastFrame = now - (elapsed % target);

      if (!frozen){
        // only advance the motion when NOT paused
        if (!paused){
          // move the seed forward to animate the glitch
          // randomness slider affects how fast it "moves"
          const speed = 1 + Math.floor(Number(randomness.value) * 10);
          motionSeed = (motionSeed + speed + (tick & 7)) >>> 0;
          tick++;
        }

        renderOnce();
      }
    }

    requestAnimationFrame(loop);
  }

  // UI wiring
  loadBtn.addEventListener('click', () => fileInput.click());

  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;

    loadedEl.textContent = f.name;

    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = () => {
      fitCanvasToImage(img.naturalWidth, img.naturalHeight);
      bctx.clearRect(0,0,base.width,base.height);
      bctx.drawImage(img, 0,0, base.width, base.height);
      imgLoaded = true;

      // reset states
      frozen = false;
      freezeBtn.textContent = "üßä Freeze";

      paused = false;
      pauseBtn.textContent = "‚è∏ Pause";
      pauseBtn.classList.remove('primary');

      // reset seeds so you get fresh motion each new load
      motionSeed = 1337;
      pausedSeed = 1337;

      renderOnce();
      URL.revokeObjectURL(url);
    };
    img.onerror = () => {
      alert("Could not load that image.");
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });

  toggleBtn.addEventListener('click', () => {
    glitchOn = !glitchOn;
    toggleBtn.textContent = glitchOn ? "‚ö° Glitch: ON" : "‚ö° Glitch: OFF";
    toggleBtn.classList.toggle('primary', glitchOn);
    if (!frozen) renderOnce();
  });

  // NEW: Pause (locks the motion seed)
  pauseBtn.addEventListener('click', () => {
    if (!imgLoaded) return;

    paused = !paused;
    if (paused){
      pausedSeed = motionSeed; // lock whatever the current motion looks like
    }
    pauseBtn.textContent = paused ? "‚ñ∂ Resume" : "‚è∏ Pause";
    pauseBtn.classList.toggle('primary', paused);

    // If frozen, don‚Äôt redraw; otherwise reflect immediate change (resume/pause)
    if (!frozen) renderOnce();
  });

  // Freeze (locks final pixels, no redraw)
  freezeBtn.addEventListener('click', () => {
    frozen = !frozen;
    freezeBtn.textContent = frozen ? "‚ñ∂ Unfreeze" : "üßä Freeze";
    // when unfreezing, re-render immediately
    if (!frozen) renderOnce();
  });

  saveBtn.addEventListener('click', () => {
    if (!imgLoaded) return;
    const a = document.createElement('a');
    a.download = "glitch.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  });

  clearBtn.addEventListener('click', () => {
    imgLoaded = false;
    loadedEl.textContent = "none";

    frozen = false;
    freezeBtn.textContent = "üßä Freeze";

    paused = false;
    pauseBtn.textContent = "‚è∏ Pause";
    pauseBtn.classList.remove('primary');

    motionSeed = 1337;
    pausedSeed = 1337;

    renderOnce();
  });

  intensity.addEventListener('input', () => {
    ival.textContent = Number(intensity.value).toFixed(2);
    if (!frozen) renderOnce(); // re-render while paused too
  });
  fps.addEventListener('input', () => fval.textContent = fps.value);
  randomness.addEventListener('input', () => {
    rval.textContent = Number(randomness.value).toFixed(2);
    if (!frozen) renderOnce();
  });

  // init labels + placeholder canvas
  ival.textContent = Number(intensity.value).toFixed(2);
  fval.textContent = fps.value;
  rval.textContent = Number(randomness.value).toFixed(2);

  canvas.width = 1280; canvas.height = 720;
  base.width = 1280; base.height = 720;
  renderOnce();

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>